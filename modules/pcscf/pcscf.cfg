#!KAMAILIO
#
# Proxy - CSCF configuration script
#
#     - web: http://www.kamailio.org
#     - web: http://www.ng-voice.com
#     - git: http://sip-router.org
#
# Direct your questions about this file to: <sr-users@lists.sip-router.org>
#
# Refer to the Core CookBook at http://www.kamailio.org/dokuwiki/doku.php
# for an explanation of possible statements, functions and parameters.
#
# Several features can be enabled using '#!define WITH_FEATURE' directives:
#
# *** To run in debug mode: 
#     - define WITH_DEBUG
#
# *** To enable Rx-Interface: 
#     - define WITH_RX
#
# *** To persistent MySQL-storage: 
#     - define WITH_DB
#     - define WITH_MYSQL
#
# *** To enable RTP-Relaying and NAT-Support: 
#     - define WITH_NAT
#
# *** To enable TLS support execute:
#     - adjust CFGDIR/tls.cfg as needed
#     - define WITH_TLS
#     - define FORCE_TLS if your devices MUST use TLS
#
# *** To enable Emergency support execute:
#     - define WITH_EMERGENCY
#
# *** To enable anti-flood detection execute:
#     - adjust pike and htable=>ipban settings as needed (default is
#       block if more than 16 requests in 2 seconds and ban for 300 seconds)
#     - define WITH_ANTIFLOOD

####### Defined Values #########

# Enabled Features on this host:
#!define WITH_NAT
#!define WITH_ANTIFLOOD

# Testing: Replacement of the builtin-dialog support with Kamailio's Dialog module
# K_TESTING

#!define HOSTNAME "pcscf"
#!define HOSTNAME_ESC "pcscf"
#!define NETWORKNAME "ng-voice.com"
#!define NETWORKNAME_ESC "ng-voice\.com"

# Data for the charging vector:
#!define ICID_GENERATOR_ADDR "109.239.50.67"
#!define ICID_VALUE_PREFIX "P-CSCFabcd"
#!define ORIG_IOI NETWORKNAME
#!define TERM_IOI NETWORKNAME

#!ifdef WITH_NAT
#!define RTPPROXY "udp:127.0.0.1:22222"
#!endif

####### Defined AVP's #########

#!ifdef K_TESTING
#!define DLG_TIMEOUT_AVP "$avp(i:1)"
#!endif

####### Defined Flags #########
#!ifdef K_TESTING
#!define DLG_FLAG 1
#!define SST_FLAG 2 
#!endif
#!ifdef WITH_NAT
#!define INVITE_SDP_FLAG 3
#!endif
#!define NAT_FLAG 4

####### Defined Values #########


####### Global Parameters #########

#!ifdef WITH_DEBUG
debug=4
log_stderror=yes
#!else
debug=1
log_stderror=no
#!endif

memdbg=5
memlog=5

log_facility=LOG_LOCAL0

fork=yes
children=4

listen=109.239.50.67
port=5060

#!ifdef WITH_TLS
enable_tls=yes
#!endif

/* uncomment the next line to disable TCP (default on) */
#disable_tcp=yes

/* comment the next line to disable the auto discovery of local aliases
   based on reverse DNS on IPs (default on) */
auto_aliases=no

server_header="Server: Proxy-CSCF"
user_agent_header="User-Agent: Proxy-CSCF"

alias="pcscf.ng-voice.com":5060

check_via=no		# (cmd. line: -v)
dns=no			# (cmd. line: -r)
rev_dns=no		# (cmd. line: -R)

# ------------------ module loading ----------------------------------
# Core Modules:
mpath="/usr/lib/kamailio/modules"
loadmodule "tm.so"
loadmodule "sl.so"
loadmodule "sanity.so"

# The P-CSCF-Module
loadmodule "pcscf.so"

#!ifdef WITH_RX
loadmodule "cdp.so"
loadmodule "cdp_avp.so"
#!endif

#!ifndef K_TESTING
# SER Modules
mpath="/usr/lib/kamailio/modules_s"
loadmodule "dialog.so"
#!endif

# Kamailio Modules
mpath="/usr/lib/kamailio/modules_k"
loadmodule "maxfwd.so"
loadmodule "rr.so"
loadmodule "mi_fifo.so"
loadmodule "pv.so"
loadmodule "xlog.so"
loadmodule "textops.so"
loadmodule "path.so"
loadmodule "siputils.so"
#!ifdef K_TESTING
loadmodule "sst.so"
loadmodule "dialog.so"
#!endif

#!ifdef WITH_NAT
loadmodule "nathelper.so"
loadmodule "rtpproxy.so"
#!endif

#!ifdef WITH_ANTIFLOOD
loadmodule "htable.so"
loadmodule "pike.so"
#!endif

# Other modules we Prefer, Core, 1st choice K, 2nd Choice SER
mpath="/usr/lib/kamailio/modules:/usr/lib/kamailio/modules_k:/usr/lib/kamailio/modules_s"

#!ifdef WITH_XMLRPC
loadmodule "xmlrpc.so"
#!endif

# ----------------- setting module-specific parameters ---------------

# ----- mi_fifo params -----
modparam("mi_fifo", "fifo_name", "/tmp/kamailio_fifo")

# ----------------- Settings for Path ---------------
# Path Module: the "received" parameter of the first Route URI is evaluated and used as destination-URI if present.
modparam("path", "use_received", 1)

# ----- dialog params -----
#!ifdef K_TESTING
#!ifdef WITH_DB
modparam("dialog", "db_url", DBURL)
modparam("dialog", "db_mode", 2)
#!endif
modparam("dialog", "dlg_flag", DLG_FLAG)
modparam("dialog", "timeout_avp", DLG_TIMEOUT_AVP)
# We need a dedicated dialog for originating and terminating
modparam("dialog", "detect_spirals", 0)

# ----- sst params -----
modparam("sst", "sst_flag", SST_FLAG)
modparam("sst", "timeout_avp", DLG_TIMEOUT_AVP)
modparam("sst", "min_se", 90) # Must be >= 90
#!endif

#!ifdef WITH_ANTIFLOOD
# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
#!endif

# ----- pv params -----
modparam("pv", "shvset", "charging_icid_value_counter=i:1")

#!ifdef WITH_NAT
# ----- rtpproxy params -----
modparam("rtpproxy", "rtpproxy_sock", RTPPROXY)
#!endif

# ----- pcscf params ----
modparam("pcscf","name","sip:pcscf.ng-voice.com:5060")

modparam("pcscf","registrar_hash_size",256)
modparam("pcscf","reginfo_dtd","/etc/kamailio/reginfo.dtd")

modparam("pcscf","subscriptions_hash_size",256)

modparam("pcscf","dialogs_hash_size",256)
modparam("pcscf","dialogs_expiration_time",3600)
modparam("pcscf","dialogs_enable_release",1)
modparam("pcscf","max_dialog_count",20000)
modparam("pcscf","min_se",90)

modparam("pcscf","use_ipsec",1)
modparam("pcscf","ipsec_host","109.239.50.67")
modparam("pcscf","ipsec_port_c",5060)
modparam("pcscf","ipsec_port_s",5060)

#!ifndef WITH_TLS
# Comment here to enable TLS!
modparam("pcscf","use_tls",0)
#!else
modparam("pcscf","use_tls",1)
modparam("pcscf","tls_port",5061)
#!endif

modparam("pcscf","ipsec_P_Inc_Req","/etc/kamailio/ipsec_P_Inc_Req.sh")
modparam("pcscf","ipsec_P_Out_Rpl","/etc/kamailio/ipsec_P_Out_Rpl.sh")
modparam("pcscf","ipsec_P_Out_Req","/etc/kamailio/ipsec_P_Out_Req.sh")
modparam("pcscf","ipsec_P_Inc_Rpl","/etc/kamailio/ipsec_P_Inc_Rpl.sh")
modparam("pcscf","ipsec_P_Drop","/etc/kamailio/ipsec_P_Drop.sh")

#!ifndef WITH_NAT
modparam("pcscf","NAT_enable", 0)
modparam("pcscf","ping", 0)
modparam("pcscf","ping_all", 0)
#!else
modparam("pcscf","NAT_enable", 1)
modparam("pcscf","ping", 1)
modparam("pcscf","ping_all", 0)
#!endif

modparam("pcscf","subscribe_retries", 1)

modparam("pcscf","assert_fallback", 0)

modparam("pcscf","icid_value_prefix","P-CSCFabcd")
modparam("pcscf","icid_gen_addr","109.239.50.67")
modparam("pcscf","orig_ioi","ng-voice.com")
modparam("pcscf","term_ioi","ng-voice.com")

# e2 Interface configuration (NASS-Bundled Authentication)
#!ifdef NASS_AUTH
modparam("pcscf","use_e2",1)
modparam("pcscf","forced_clf_peer","clf.ng-voice.com")
#!else
modparam("pcscf","use_e2",0)
#!endif

# PCC interface configuration
#
#!ifndef WITH_RX
modparam("pcscf","use_pcc",0)
#!else
modparam("pcscf","use_pcc",1)
modparam("pcscf","forced_qos_peer","pcrf.ng-voice.com")
# Should it use Gq' (Rel.6) Or Rx (Rel.7)?
modparam("pcscf","qos_release7",1)
# The IP address of the P-CSCF, to build the default signaling bearer with, on registration 
modparam("pcscf","ipv4_for_signaling","109.239.50.67")
modparam("pcscf","ipv6_for_signaling","::1")
modparam("pcscf","port_for_signaling",5060)
#enable or disable using the ports in the IPFilterRule
modparam("pcscf","pcc_use_ports",1)
#Generic gateway configuration
modparam("pcscf","gg_ip","109.239.50.67")
modparam("pcscf","gg_port",10001)
#!endif

#!ifndef WITH_EMERGENCY
#set the emergency support: 0 for disable and 1 for enable
modparam("pcscf","emerg_support",0)
#!else
modparam("pcscf","emerg_support",1)
modparam("pcscf","ecscf_uri", "sip:ecscf.ng-voice.com:7060")
modparam("pcscf","emerg_numbers_file", "/etc/kamailio/emerg_info.xml")
#!endif

# ----- cdp params -----
#!ifdef WITH_RX
# Uncomment here to load C Diameter Peer - requires to enable the e2 or/and PCC interface 
# (NASS-Bundled Authentication / PoCCA - EPC) or the PCRF ones
modparam("cdp", "config_file", "/etc/kamailio/pcscf.xml")
#!endif

# ----- rr params -----
# add value to ;lr param to make some broken UAs happy
modparam("rr", "enable_full_lr", 1)

#!ifdef WITH_TLS
# ----- tls params -----
modparam("tls", "config", "/etc/kamailio/tls.cfg")
#!endif

# -------------------------  request routing logic -------------------

# main routing logic
route {
	xlog("L_ERR", "$rm $ru (From $fu / $si)\n");	

	# Basic checks for Sanity of the request and Request flooding.	
	route(Sanity_Checks);

	# Thus P_check_via_sent_by/P_add_via_received is no longer required.
	route(NAT);

	if (is_method("REGISTER")) {
		route(REGISTER);
		break;
	}
#!ifdef FORCE_TLS
	# Only allow REGISTER as unprotected message 	
	else {
		if (!is_peer_verified()) {
			append_to_reply("Proxy-Require: sec-agree\r\n");
			send_reply("494","Security Agreement Required");
			exit;
		}
	}
#!endif

	if (is_method("NOTIFY") && uri==myself){
		route(NOTIFY);
		break;
	}
	
	xlog("L_ERR", "$$route_uri = $route_uri\n");
	if !($route_uri =~ "sip:term@"+HOSTNAME_ESC+"."+NETWORKNAME_ESC+".*") {
		# Request Initiated by the UE
#!ifdef K_TESTING
		if (is_in_profile("orig")){
#!else
		if (P_is_in_dialog("orig") || has_totag()){
#!endif
			if (!is_method("CANCEL")) route(Orig_Subsequent);
			else route(Orig_Standalone);
			break;
		}
#!ifdef K_TESTING
		if (is_in_profile("term")){
#!else
		if (P_is_in_dialog("term") || has_totag()){
#!endif
			if (!is_method("CANCEL")) route(Term_Subsequent);
			else route(Orig_Standalone);
			break;
		}
		xlog("L_ERR", "No dialog yet\n");		
		# No dialog yet - ACK not relayed as hop-to-hop
		if (is_method("ACK"))
			break;
		
		# Check for Retransmissions
		t_check_trans();

		if (is_method("INVITE|SUBSCRIBE")){
			route(Orig_Initial);
			break;
		}else{
			if (is_method("UPDATE")){
				send_reply("403","Forbidden - Target refresh outside dialog not allowed");
				break;
			}
			if (is_method("BYE|PRACK")){
				send_reply("403","Forbidden - Originating subsequent requests outside dialog not allowed");
				break;
			}
			route(Orig_Standalone);
			break;
		}
	}else{
		# TODO - check if this does come from an UE and that UE is unregistered
		
		# Request Terminated by the UE
#!ifdef K_TESTING
		if (!is_in_profile("term") && is_method("INVITE|SUBSCRIBE")){
#!else
		if (!P_is_in_dialog("term") && is_method("INVITE|SUBSCRIBE")){
#!endif
			route(Term_Initial);
			break;
		} else {
#!ifdef K_TESTING
			if (is_in_profile("term")){
#!else
			if (P_is_in_dialog("term")){
#!endif

				if (!is_method("CANCEL")) route(Term_Subsequent);
				else route(Term_Standalone);
				break;
			}else{
				if (is_method("UPDATE")) {
					send_reply("403","Forbidden - Target refresh outside dialog not allowed");
					break;
				}
				if (is_method("BYE|ACK|PRACK")){
					send_reply("403","Forbidden - Terminating subsequent requests outside dialog not allowed");
					break;
				}				
				route(Term_Standalone);
				break;
			}
		}		
		break;
	}
}


# Caller NAT detection route
route[NAT] {
#!ifdef WITH_NAT
	force_rport();
	if (nat_uac_test("19")) {
		setflag(NAT_FLAG);
		if (is_method("INVITE")) {
			fix_nated_contact();
		}
	}
#!endif
	return;
}

# RTPProxy control
route[RTPPROXY] {
#!ifdef WITH_NAT
	if (is_method("BYE")) {
		unforce_rtp_proxy();
	} else if (isflagset(NAT_FLAG) && is_method("INVITE") && !search("^Content-Length:[ ]*0")) {
		setflag(INVITE_SDP_FLAG);
		rtpproxy_offer();
	} else if (isflagset(NAT_FLAG) && is_method("ACK") && !search("^Content-Length:[ ]*0")) {
		rtpproxy_answer();
	}
#!endif
	return;
}

route[RTPPROXY_REPLY] {
#!ifdef WITH_NAT
	if (isflagset(NAT_FLAG) && status=~"(183)|(2[0-9][0-9])" && !search("^Content-Length:[ ]*0")) {
		if (isflagset(INVITE_SDP_FLAG)) rtpproxy_answer();
		else rtpproxy_offer();
	}
#!endif
	return;
}

route[Sanity_Checks]
{
#!ifdef WITH_ANTIFLOOD
	# flood dection from same IP and traffic ban for a while
	# be sure you exclude checking trusted peers, such as pstn gateways
	# - local host excluded (e.g., loop to self)
	if(src_ip!=myself)
	{
		if($sht(ipban=>$si)!=$null)
		{
			# ip is already blocked
			xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
			exit;
		}
		if (!pike_check_req())
		{
			xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
			$sht(ipban=>$si) = 1;
			exit;
		}
	}
#!endif

	if (!mf_process_maxfwd_header("10")) {
		send_reply("483","Too Many Hops");
		exit;
	}

	if(!sanity_check("1511", "7"))
	{
		xlog("L_INFO","Malformed SIP message from $si:$sp\n");
		exit;
	}
}

route[Check_Session_Expires]
{
#!ifdef K_TESTING
	if (is_method("INVITE")) {
		if (sstCheckMin("1")) {
			xlog("L_ERR", "422 Session Timer Too Small reply sent.\n");
			exit;
		}
		# track the session timers via the dialog module
		setflag(DLG_FLAG);
		setflag(SST_FLAG);
	}
#!else
        if (!P_check_session_expires()) {
                P_422_session_expires();
                exit;
        };  
#!endif
}	


route[REGISTER_494]
{
	append_to_reply("Proxy-Require: sec-agree\r\n");
	send_reply("494","Security Agreement Required");
}

route[add_charging_vector]
{
	$var(charging_vector) = "icid-value=\""+ICID_VALUE_PREFIX+$(Ts{s.encode.hexa})+$(shv(charging_icid_value_counter){s.encode.hexa})+"\";icid-generated-at="+ICID_GENERATOR_ADDR+";orig-ioi=\""+ORIG_IOI+"\"";
	append_hf("P-Charging-Vector: $var(charging_vector)\r\n");

	# Increase counter by one:
	$shv(charging_icid_value_counter) = $shv(charging_icid_value_counter) + 1;
}

route[REGISTER]
{
#!ifndef WITH_EMERGENCY
	$var(ct_uri) = $(ct{re.subst,/\".*\"[ ]*//i}{re.subst,/<//i}{re.subst,/>//i});
	if ($(var(ct_uri){uri.params}{param.value,sos})) {
		# P_380_em_alternative_serv("no Emergency Services support at this PCSCF");
		#TODO: Fix XML-Body
		set_reply_body("<xml>no Emergency Services support at this PCSCF</xml>", "application/3gpp-ims+xml;schemaversion=\"1\"");
		send_reply("503", "Service Unavailable");
		exit;	
	}
#!endif
	if (!P_verify_security()) {
		route(REGISTER_494);
		break;
	};
	if (!P_is_integrity_protected()){
		#Variant 1 - accept also non IPSec clients
		remove_hf("Security-Client");
		
		#Variant 2 - accept only IPSec clients
		#if (!is_present_hf("Security-Client")){
		#	route(REGISTER_494);
		#	break;
		#}
		remove_hf("Security-Client");

		# Set the "integrity protected tag in the Authorization-Header:
		if (is_present_hf("Authorization") && $hdr(Authorization) =~ ".*integrity-protected.*"){
			remove_hf("Authorization");
			$var(new_hdr) = $(hdr(Authorization){re.subst,/[, ]*integrity-protected=\"[a-zA-Z0-9]*\"//i});
			append_hf("Authorization: $var(new_hdr), integrity-protected=\"no\"\r\n");
		}
	}else{
		if (!is_present_hf("Security-Verify")||!is_present_hf("Security-Client")){
			route(REGISTER_494);		
			break;
		}
		remove_hf("Security-Verify");
		remove_hf("Security-Client");

		# Set the "integrity protected tag in the Authorization-Header:
		if (is_present_hf("Authorization") && $hdr(Authorization) =~ ".*integrity-protected.*"){
			remove_hf("Authorization");
			$var(new_hdr) = $(hdr(Authorization){re.subst,/[, ]*integrity-protected=\"[a-zA-Z0-9]*\"//i});
			append_hf("Authorization: $var(new_hdr), integrity-protected=\"yes\"\r\n");
		}
	};
	# Check for "sec-agree" in the Require header:
	if (is_present_hf("Require") && $hdr(Require) =~ ".*sec-agree.*") {
		# The new Require-Header:
		remove_hf("Require");
		# Replace ", sec-agree" with ""
		$var(new_hdr) = $(hdr(Require){re.subst,/[, ]*sec-agree//gi});
		if ($(var(new_hdr){s.len}) > 0) {
			append_hf("Require: $var(new_hdr)\r\n");
		}
	}
	# Check for "sec-agree" in the Proxy-Require header:
	if (is_present_hf("Proxy-Require") && $hdr(Proxy-Require) =~ ".*sec-agree.*") {
		# The new Require-Header:
		remove_hf("Proxy-Require");
		# Replace ", sec-agree" with ""
		$var(new_hdr) = $(hdr(Proxy-Require){re.subst,/[, ]*sec-agree//gi});
		if ($(var(new_hdr){s.len}) > 0) {
			append_hf("Proxy-Require: $var(new_hdr)\r\n");
		}
	}
	remove_hf("Security-Verify");
	# Add a term path-Header:
	if (isflagset(NAT_FLAG)) {
		if ($pr == "udp")
			append_hf("Path: <sip:term@"+HOSTNAME+"."+NETWORKNAME+";lr;received=sip:$si:$sp>\r\n");
		else
			append_hf("Path: <sip:term@"+HOSTNAME+"."+NETWORKNAME+";lr;received=sip:$si:$sp;transport=$pr>\r\n");
	} else
		append_hf("Path: <sip:term@"+HOSTNAME+"."+NETWORKNAME+";lr>\r\n");
	
	append_hf("Require: path\r\n");
	# Add a charging vector:
	route(add_charging_vector);
	# Add a visited Network-ID-Header:
	if (is_present_hf("P-Visited-Network-ID")) {
		$var(new_hdr) = NETWORKNAME+", "+$hdr(P-Visited-Network-ID);
		append_hf("P-Visited-Network-ID: $var(new_hdr)\r\n");
	} else {
		append_hf("P-Visited-Network-ID: "+NETWORKNAME+"\r\n");
	}
#!ifdef NASS_AUTH
	# trigger the UDR on the e2 interface (NASS-Bundled Authentication)
	P_access_network_info("ng-voice.com");
#!endif
	t_on_reply("REGISTER_reply");
	t_on_failure("REGISTER_failure");
		
	if (!t_relay()) {
		send_reply("500","Error forwarding to Home Domain");
		break;
	};
}

onreply_route[REGISTER_reply]
{
	if (t_check_status("401")){
		xlog("L_ERR", "401:\n");
		# Check for "sec-agree" in the Proxy-Require header:
		if (is_present_hf("WWW-Authenticate") && ($hdr(WWW-Authenticate) =~ ".*ck=.*" || $hdr(WWW-Authenticate) =~ ".*ik=.*")) {
			$var(new_hdr) = $hdr(WWW-Authenticate);
			xlog("L_ERR", "$$var(new_hdr) = $var(new_hdr)\n");
			if ($var(new_hdr) =~ ".*ck=.*") {
				# Replace ", (ck/ik)" with ""
				$var(new_hdr) = $(var(new_hdr){re.subst,/[, ]*ck=\"[0-9A-Za-z]*\"//i});
				xlog("L_ERR", "CK: $$var(new_hdr) = $var(new_hdr)\n");
			}
			if ($var(new_hdr) =~ ".*ik=.*") {
				# Replace ", (ck/ik)" with ""
				$var(new_hdr) = $(var(new_hdr){re.subst,/[, ]*ik=\"[0-9A-Za-z]*\"//i});
				xlog("L_ERR", "IK: $$var(new_hdr) = $var(new_hdr)\n");
			}
			# Replace the header:
			remove_hf("WWW-Authenticate");
			append_hf("WWW-Authenticate: $var(new_hdr)\r\n");
		} else {
#			send_reply("500","P-CSCF Error on hiding CK, IK");
			break;
		}
		P_security_401();
	}
	if (t_check_status("200")){
		if (!P_save_location()){
#			send_reply("500","P-CSCF Error on saving location");
			break;
		}		
		P_security_200();
		P_subscribe();
		if(is_present_hf("Expires") && $(hdr(Expires){s.int})==0) P_STR("reg");
		else P_AAR("register");		
	}
#!ifdef WITH_TLS
	P_security_relay();
#!endif
}

failure_route[REGISTER_failure]
{
	if (t_check_status("408"))
		send_reply("504","Server Time-Out");
}

route[NOTIFY]
{
	if (P_process_notification()) {
		send_reply("200","OK - P-CSCF processed notification");
		break;
	}else{
		send_reply("500","Error encountered while processing notification");
		break;
	}   
}

#######                   ORIGINATING
route[Orig_Initial]
{
	if (P_emergency_ruri()){
		route(Orig_Initial_Emergency);
		break;
	}

	if (!P_is_registered()){
	        send_reply("403","Forbidden - Not Registered! You must register first with a S-CSCF");
	        break;
	};
	if (!P_assert_identity("non-emerg")){
	        send_reply("403","Forbidden - You must register first with a S-CSCF");
	        break;
	};
	# add IBCF/THIG route here if required
	loose_route();
	if (!P_follows_service_routes()){		
		#Variant 1 - deny access to the network
		#send_reply("400","Bad Request - Not following indicated Service-Routes");		    
		#break;
		#Variant 2 - enforce routes and let the dialog continue
   		P_enforce_service_routes();
	}			
	
	P_record_route("orig");

	# Check for "sec-agree" in the Require header:
	if (is_present_hf("Require") && $hdr(Require) =~ ".*sec-agree.*") {
		# The new Require-Header:
		remove_hf("Require");
		# Replace ", sec-agree" with ""
		$var(new_hdr) = $(hdr(Require){re.subst,/[, ]*sec-agree//i});
		if ($(var(new_hdr){s.len}) > 0) {
			append_hf("Require: $var(new_hdr)\r\n");
		}
	}
	# Check for "sec-agree" in the Proxy-Require header:
	if (is_present_hf("Proxy-Require") && $hdr(Proxy-Require) =~ ".*sec-agree.*") {
		# The new Require-Header:
		remove_hf("Proxy-Require");
		# Replace ", sec-agree" with ""
		$var(new_hdr) = $(hdr(Proxy-Require){re.subst,/[, ]*sec-agree//i});
		if ($(var(new_hdr){s.len}) > 0) {
			append_hf("Proxy-Require: $var(new_hdr)\r\n");
		}
	}
	remove_hf("Security-Verify");

	route(add_charging_vector);	
	
	route(Check_Session_Expires);	
			
	if (!P_save_dialog("orig","non-emerg")){
		send_reply("514","Originating dialog save failure - P-CSCF maximum dialog count reached!");
		exit;
	}

	if (isflagset(NAT_FLAG) && is_method("INVITE")){
		#P_local_policy(); #check, if sdp is allowed, if not return with allowed sdp
		route(RTPPROXY);
	}
		
	t_on_reply("Orig_Initial_reply");
	t_on_failure("Orig_Initial_failure");
	if (!t_relay()) {
		send_reply("500","Error forwarding originating initial request");
		# Calls void terminate_pcc_session(str session_id):
		P_drop_dialog("orig");
		break;
	};
}

route[Orig_Initial_Emergency]
{
	route(Verify_Emergency);

	P_record_route("orig");

	# Check for "sec-agree" in the Require header:
	if (is_present_hf("Require") && $hdr(Require) =~ ".*sec-agree.*") {
		# The new Require-Header:
		remove_hf("Require");
		# Replace ", sec-agree" with ""
		$var(new_hdr) = $(hdr(Require){re.subst,/[, ]*sec-agree//gi});
		if ($(var(new_hdr){s.len}) > 0) {
			append_hf("Require: $var(new_hdr)\r\n");
		}
	}
	# Check for "sec-agree" in the Proxy-Require header:
	if (is_present_hf("Proxy-Require") && $hdr(Proxy-Require) =~ ".*sec-agree.*") {
		# The new Require-Header:
		remove_hf("Proxy-Require");
		# Replace ", sec-agree" with ""
		$var(new_hdr) = $(hdr(Proxy-Require){re.subst,/[, ]*sec-agree//gi});
		if ($(var(new_hdr){s.len}) > 0) {
			append_hf("Proxy-Require: $var(new_hdr)\r\n");
		}
	}
	remove_hf("Security-Verify");	
	route(add_charging_vector);	
	
	route(Check_Session_Expires);	

	if (!P_save_dialog("orig", "emerg")){
		send_reply("514","Originating dialog save failure - P-CSCF maximum dialog count reached!");
		exit;
	}
	#select and enforce a route to an ECSCF
	if(!P_select_ecscf()){
	        send_reply("503","Internal Error, could not select an E-CSCF");
		exit;
	}
	if(!P_enforce_sos_routes()){
	        send_reply("503","Internal Error, could not select an ECSCF");
	        exit;
	}
	
	if(!P_add_em_path()){
		send_reply("503","Internal Error, could not send the INVITE");
		exit;
	}
		
	if (isflagset(NAT_FLAG) && is_method("INVITE")){
		route(RTPPROXY);
	}
		
	t_on_reply("Orig_Initial_reply");
	t_on_failure("Orig_Initial_failure");
	
	if (!t_relay()) {
		send_reply("500","Error forwarding originating initial request");
		P_drop_dialog("orig");
		break;
	};

}

route[Verify_Emergency]
{
#!ifndef WITH_EMERGENCY
	#TODO: Fix XML-Body
	set_reply_body("<xml>no Emergency Services support at this PCSCF</xml>", "application/3gpp-ims+xml;schemaversion=\"1\"");
	send_reply("380", "Alternative Services");
	exit;
#!endif
	
	if (P_is_anonymous_user()){
		if(P_accept_anonym_em_call()){
			log(1,">> Anonymous caller! sending it to E-CSCF\n");
		}else{
			send_reply("503", "Service Unavailable");
			exit;
		}
	}else{
		#non-roaming user
		if(from_uri=~".*@ng-voice\.com.*"){
			if(!P_is_registered()){

				if (!P_is_em_registered()){#TODO: Alternative Service
					P_380_em_alternative_serv("You must first do an Emergency Registration");    
					send_reply("380", "Alternative Services");
		        		exit;
				};
				if (!P_assert_identity("emerg")){
		        		send_reply("403","Forbidden - You must register first with a S-CSCF or use an Anonymous Identity for Emergency");
				        exit;
				};

			}else {
				if (!P_assert_identity("non-emerg")){
		        		send_reply("403","Forbidden - You must register first with a S-CSCF or use an Anonymous Identity for Emergency");
				        exit;
				};
			}
		}else{
			if (!P_is_em_registered()){#TODO: Alternative Service
					P_380_em_alternative_serv("roaming users must first do an Emergency Registration");    
					send_reply("380", "Alternative Services");
		        		exit;
			};
			if (!P_assert_identity("emerg")){
	        		send_reply("403","Forbidden - You must register first with a S-CSCF or use an Anonymous Identity for Emergency");
			        exit;
			};

		}
	}

}


onreply_route[Orig_Initial_reply]
{
	if (!t_check_status("(408)|(480)|(487)|(488)|(503)|(603)")){
		P_update_dialog("orig");
	}else{
		P_STR("orig");
		P_drop_dialog("orig");
		break;
	}	
	
	if (t_check_status("(180)|(183)|([2-9]..)")){
		route(RTPPROXY_REPLY);	
		if (P_generates_aar("orig")) {	
			if (!P_AAR("orig")) {
				P_release_call_onreply("orig");
			} else {
				if (!P_security_relay()) P_NAT_relay();		
			}		
		} else {
			if (!P_security_relay()) P_NAT_relay();		
		}
	}

	break;
}

failure_route[Orig_Initial_failure]
{
	if (t_check_status("(408)|(480)")){
		P_drop_dialog("orig");
		break;
	}
	break;
}


route[Orig_Subsequent]
{
	log(1,">>       Orig_Subsequent\n");
	if (P_is_registered()){
		if (!P_assert_identity("non-emerg")){
			xlog("L_ERR", "Not registered!\n");
		        send_reply("403","Forbidden - You must register first with a S-CSCF");
	    	    break;
		};
	}else if (P_is_em_registered()){
		if (!P_assert_identity("emerg")){
		        send_reply("403","Forbidden - You must register first with a S-CSCF");
	    	    break;
		};
	}

	loose_route();

	if (method!="CANCEL" && !P_follows_dialog_routes("orig")){		
		log(1,">>       Orig_Subsequent: Request not following indicated dialog routes\n");
		#Variant 1 - deny access to the network
		#if (method!=ACK){
		#    send_reply("400","Bad Request - Not following indicated dialog routes");
		#} else{
		#	log(1,">>	Orig_Subsequent: ACK not following dialog routes discarded silently!!!\n");
		#}
		#break;
		#Variant 2 - enforce routes and let the dialog continue
		P_enforce_dialog_routes("term");
		#break;
	}	
		
	#P_record_route("orig");

	route(Check_Session_Expires);	

	P_update_dialog("orig");	

	if (method=="INVITE" || method=="ACK" || method=="BYE"){
		route(RTPPROXY);
	}
	
	if (method=="BYE" || method=="CANCEL"){
		P_STR("orig");		
	}	

	# Check for "sec-agree" in the Require header:
	if (is_present_hf("Require") && $hdr(Require) =~ ".*sec-agree.*") {
		# The new Require-Header:
		remove_hf("Require");
		# Replace ", sec-agree" with ""
		$var(new_hdr) = $(hdr(Require){re.subst,/[, ]*sec-agree//gi});
		if ($(var(new_hdr){s.len}) > 0) {
			append_hf("Require: $var(new_hdr)\r\n");
		}
	}
	# Check for "sec-agree" in the Require header:
	if (is_present_hf("Proxy-Require") && $hdr(Proxy-Require) =~ ".*sec-agree.*") {
		# The new Require-Header:
		remove_hf("Proxy-Require");
		# Replace ", sec-agree" with ""
		$var(new_hdr) = $(hdr(Proxy-Require){re.subst,/[, ]*sec-agree//gi});
		if ($(var(new_hdr){s.len}) > 0) {
			append_hf("Proxy-Require: $var(new_hdr)\r\n");
		}
	}
        P_remove_security_verify();

	# reply routes unused as empty at the moment
	t_on_reply("Orig_Subsequensend_reply");
	#t_on_failure("Orig_Subsequent_failure");
	xlog("L_ERR", "$rm: Forward to $ru ($du)\n");	
	if (!t_relay()) {
		xlog("L_ERR", "Could not forward\n");
		send_reply("500","Error forwarding originating subsequent request");
		break;
	};
}

onreply_route[Orig_Subsequensend_reply]
{
	if (t_check_status("[1-2]..")){
		P_update_dialog("orig");		
	}
	
	if (t_check_status("2..") && P_generates_aar("orig")){
		if (!P_AAR("orig")) {
			P_release_call_onreply("orig");
		} 
	}	
	
	if (!P_security_relay()) 
			P_NAT_relay();
	break;
}

failure_route[Orig_Subsequent_failure]
{
	break;
}


route[Orig_Standalone]
{
	loose_route();
	t_newtran();
	if (P_emergency_ruri()){
		route(Verify_Emergency);
		if(!P_enforce_sos_routes()){
		        send_reply("503","Internal Error, could not fwd to an E-CSCF");
		        exit;
		}
	}else{	
		if (!P_is_registered()){
		        send_reply("403","Forbidden - You must register first with a S-CSCF");
			break;
		}
		if (!P_assert_identity("non-emerg")){
			send_reply("403","Forbidden - You must register first with a S-CSCF");
	    	    	break;
		};
	
		if (!P_follows_service_routes()){		
			#Variant 1 - deny access to the network
			#send_reply("400","Bad Request - Not following indicated service routes");
			#break;
			#Variant 2 - enforce routes and let the dialog continue
   			P_enforce_service_routes();
		}	
	}

	# add IBCF/THIG route here if required
	# Check for "sec-agree" in the Require header:
	if (is_present_hf("Require") && $hdr(Require) =~ ".*sec-agree.*") {
		# The new Require-Header:
		remove_hf("Require");
		# Replace ", sec-agree" with ""
		$var(new_hdr) = $(hdr(Require){re.subst,/[, ]*sec-agree//gi});
		if ($(var(new_hdr){s.len}) > 0) {
			append_hf("Require: $var(new_hdr)\r\n");
		}
	}
	# Check for "sec-agree" in the Proxy-Require header:
	if (is_present_hf("Proxy-Require") && $hdr(Proxy-Require) =~ ".*sec-agree.*") {
		# The new Require-Header:
		remove_hf("Proxy-Require");
		# Replace ", sec-agree" with ""
		$var(new_hdr) = $(hdr(Proxy-Require){re.subst,/[, ]*sec-agree//gi});
		if ($(var(new_hdr){s.len}) > 0) {
			append_hf("Proxy-Require: $var(new_hdr)\r\n");
		}
	}
	remove_hf("Security-Verify");
	route(add_charging_vector);			

	# reply routes unused as empty at the moment
	t_on_reply("Orig_Standalone_reply");
	#t_on_failure("Orig_Standalone_failure");
	
	if (!t_relay()) {
		send_reply("500","Error forwarding originating standalone request");
		break;
	};

}

onreply_route[Orig_Standalone_reply]
{
	#P_store_charging();
	if (!P_security_relay()) 
			P_NAT_relay();
	break;
}

failure_route[Orig_Standalone_failure]
{
	break;
}


#######                   TERMINATING

route[Term_Initial]
{
	P_record_route("term");

	route(Check_Session_Expires);	

	if (!P_save_dialog("term","non-emerg")){
		send_reply("514","Terminating dialog save failure - P-CSCF maximum dialog count reached!");
		exit;
	}
	
	loose_route();
	if (check_route_param("received=.*")) setflag(NAT_FLAG);
	if (isflagset(NAT_FLAG)) xlog("L_ERR", "Callee is behind NAT!\n");
		
	t_on_reply("Term_Initial_reply");
	#t_on_failure("Term_Initial_failure");
	if (is_method("INVITE") && isflagset(NAT_FLAG)) {
		route(RTPPROXY);
	}	
	P_security_relay(); 

	t_on_reply("Term_Initial_reply");
	t_on_failure("Term_Initial_failure");
	if (!t_relay()) {
		send_reply("500","Error forwarding terminating initial request");
		P_drop_dialog("term");
		break;
	};
}


onreply_route[Term_Initial_reply]
{
	if (t_check_status("(180)|(183)|([2-9]..)")){
		if (isflagset(NAT_FLAG)) {
			# Fix Contact Header in Reply to INVITE
			fix_nated_contact();
			# Use RTP-Proxy, if required:
			route(RTPPROXY_REPLY);
		}
		if(P_generates_aar("term")){
			# check if QoS is ok, orig - originating, term - terminating 
			if (!P_AAR("term")) {
				P_release_call_onreply("term");
			}			
		}
	}
	
	if (!P_follows_via_list()) {
		log(1,">>      P_follows_via_list - failed");
		P_enforce_via_list();
	};
	
	if (t_check_status("(1[1-9].)|(1.[1-9])|(2..)")){
		if (!P_follows_record_routes()){
			log(1,">>      P_follows_record_routes - failed\n");
			P_enforce_record_routes();
		}	    
	}
	
	if (!t_check_status("(408)|(480)")){
		P_assert_called_identity();
		P_update_dialog("term");		
	}else{
		P_drop_dialog("term");
		P_STR("term");
		break;
	}
	
			
}

failure_route[Term_Initial_failure]
{
	if (t_check_status("(408)|(480)")){
		P_drop_dialog("term");
		break;
	}

	if (!P_follows_via_list()) {
		log(1,">>      P_follows_via_list - failed - this is a bug in P_follows_via_list()!\n");
	#	P_enforce_via_list();
	};

	break;
}



route[Term_Subsequent]
{
	log(1,">>       Term_Subsequent\n");

	route(Check_Session_Expires);	

	P_update_dialog("term");
	
	loose_route();
	
	#P_record_route("term");

	if (method=="INVITE"||method=="ACK" || method=="BYE") {
		route(RTPPROXY);
	}
	
	if (method=="BYE") {
		P_STR("term"); # terminate authorization session
	}	

	# Check for "sec-agree" in the Require header:
	if (is_present_hf("Require") && $hdr(Require) =~ ".*sec-agree.*") {
		# The new Require-Header:
		remove_hf("Require");
		# Replace ", sec-agree" with ""
		$var(new_hdr) = $(hdr(Require){re.subst,/[, ]*sec-agree//gi});
		if ($(var(new_hdr){s.len}) > 0) {
			append_hf("Require: $var(new_hdr)\r\n");
		}
	}
	# Check for "sec-agree" in the Proxy-Require header:
	if (is_present_hf("Proxy-Require") && $hdr(Proxy-Require) =~ ".*sec-agree.*") {
		# The new Require-Header:
		remove_hf("Proxy-Require");
		# Replace ", sec-agree" with ""
		$var(new_hdr) = $(hdr(Proxy-Require){re.subst,/[, ]*sec-agree//gi});
		if ($(var(new_hdr){s.len}) > 0) {
			append_hf("Proxy-Require: $var(new_hdr)\r\n");
		}
	}
	remove_hf("Security-Verify");

	t_on_reply("Term_Subsequensend_reply");
	#t_on_failure("Term_Subsequent_failure");
	P_security_relay();

	xlog("L_ERR", "$rm: Forward to $ru ($du)\n");	
	if (!t_relay()) {
		send_reply("500","Error forwarding terminating subsequent request");
		break;
	};

}

onreply_route[Term_Subsequensend_reply]
{
	if (!P_follows_via_list()) {
		log(1,">>      P_follows_via_list - failed\n");
		P_enforce_via_list();
	};	
	if (t_check_status("[1-2]..")){
		P_update_dialog("term");		
	}	

	if (t_check_status("(180)|(183)|([2-9]..)")){
		if(P_generates_aar("term")){
			# check if QoS is ok, orig - originating, term - terminating 
			if (!P_AAR("term")) {
				P_release_call_onreply("term");
			#   end_media_session();
			#} else {
			#	use_media_proxy(); 
			}			
		}
	}

	break;
}

failure_route[Term_Subsequent_failure]
{
	if (!P_follows_via_list()) {
		log(1,">>      P_follows_via_list - failed\n");
		P_enforce_via_list();
	};
	break;
}


route[Term_Standalone]
{
	loose_route();		

	t_on_reply("Term_Standalone_reply");
	#t_on_failure("Term_Standalone_failure");
	P_security_relay();
	if (!t_relay()) {
		send_reply("500","Error forwarding terminating standalone request");
		break;
	};
	
}

onreply_route[Term_Standalone_reply]
{
	P_assert_called_identity();
	if (!P_follows_via_list()) {
		log(1,">>      P_follows_via_list - failed\n");
		P_enforce_via_list();
	};
	break;
}

failure_route[Term_Standalone_failure]
{
	if (!P_follows_via_list()) {
		log(1,">>      P_follows_via_list - failed\n");
		P_enforce_via_list();
	};
	break;
}

