#!KAMAILIO
#
# Proxy - CSCF configuration script
#
#     - web: http://www.kamailio.org
#     - web: http://www.ng-voice.com
#     - git: http://sip-router.org
#
# Direct your questions about this file to: <sr-users@lists.sip-router.org>
#
# Refer to the Core CookBook at http://www.kamailio.org/dokuwiki/doku.php
# for an explanation of possible statements, functions and parameters.
#
# Several features can be enabled using '#!define WITH_FEATURE' directives:
#
# *** To run in debug mode: 
#     - define WITH_DEBUG
#
# *** To enable Rx-Interface: 
#     - define WITH_RX
#
# *** To enable RTP-Relaying and NAT-Support: 
#     - define WITH_NAT
#
# *** To enable TLS support execute:
#     - adjust CFGDIR/tls.cfg as needed
#     - define WITH_TLS
#
# *** To enable Emergency support execute:
#     - define WITH_EMERGENCY
#
# *** To enable anti-flood detection execute:
#     - adjust pike and htable=>ipban settings as needed (default is
#       block if more than 16 requests in 2 seconds and ban for 300 seconds)
#     - define WITH_ANTIFLOOD

####### Defined Values #########

# Enabled Features on this host:
#!define WITH_NAT
#!define WITH_ANTIFLOOD

####### Defined Values #########

#!ifdef WITH_RX
#!define WITH_CDP
#!endif

#!ifdef WITH_NAT
#!define RTPPROXY "udp:127.0.0.1:22222"
#!endif

####### Global Parameters #########

#!ifdef WITH_DEBUG
debug=4
log_stderror=yes
#!else
debug=2
log_stderror=no
#!endif

memdbg=5
memlog=5

log_facility=LOG_LOCAL0

fork=yes
children=4

listen=109.239.50.67
port=5060

#!ifdef WITH_TLS
enable_tls=yes
#!endif

/* uncomment the next line to disable TCP (default on) */
#disable_tcp=yes

/* comment the next line to disable the auto discovery of local aliases
   based on reverse DNS on IPs (default on) */
auto_aliases=no

server_header="Server: Proxy-CSCF"
user_agent_header="User-Agent: Proxy-CSCF"

alias="pcscf.ng-voice.com":5060

check_via=no		# (cmd. line: -v)
dns=no			# (cmd. line: -r)
rev_dns=no		# (cmd. line: -R)

# ------------------ module loading ----------------------------------
# Core Modules:
mpath="/usr/lib/kamailio/modules"
loadmodule "tm.so"
loadmodule "sl.so"
loadmodule "sanity.so"

# The P-CSCF-Module
loadmodule "pcscf.so"

# SER Modules
mpath="/usr/lib/kamailio/modules_s"
loadmodule "dialog.so"

# Kamailio Modules
mpath="/usr/lib/kamailio/modules_k"
loadmodule "maxfwd.so"
loadmodule "rr.so"
loadmodule "mi_fifo.so"
loadmodule "pv.so"
loadmodule "xlog.so"
loadmodule "textops.so"

# Other modules we Prefer, Core, 1st choice K, 2nd Choice SER
mpath="/usr/lib/kamailio/modules:/usr/lib/kamailio/modules_k:/usr/lib/kamailio/modules_s"

#!ifdef WITH_NAT
loadmodule "nathelper.so"
loadmodule "rtpproxy.so"
#!endif

#!ifdef WITH_CDP
loadmodule "cdp.so"
loadmodule "cdp_avp.so"
#!endif

#!ifdef WITH_ANTIFLOOD
loadmodule "htable.so"
loadmodule "pike.so"
#!endif

#!ifdef WITH_XMLRPC
loadmodule "xmlrpc.so"
#!endif

# ----------------- setting module-specific parameters ---------------

# ----- mi_fifo params -----
modparam("mi_fifo", "fifo_name", "/tmp/kamailio_fifo")

# ----- dialog params -----
#modparam("dialog", "dlg_flag", 1)

# ----- pcscf params -----
modparam("pcscf","name","sip:pcscf.ng-voice.com:5060")

modparam("pcscf","registrar_hash_size",256)
modparam("pcscf","reginfo_dtd","/etc/kamailio/reginfo.dtd")

modparam("pcscf","subscriptions_hash_size",256)

modparam("pcscf","dialogs_hash_size",256)
modparam("pcscf","dialogs_expiration_time",3600)
modparam("pcscf","dialogs_enable_release",1)
modparam("pcscf","max_dialog_count",20000)
modparam("pcscf","min_se",90)

modparam("pcscf","use_ipsec",1)
modparam("pcscf","ipsec_host","109.239.50.67")
modparam("pcscf","ipsec_port_c",5060)
modparam("pcscf","ipsec_port_s",5060)

#!ifndef WITH_TLS
# Comment here to enable TLS!
modparam("pcscf","use_tls",0)
#!else
modparam("pcscf","use_tls",1)
modparam("pcscf","tls_port",5061)
#!endif

modparam("pcscf","ipsec_P_Inc_Req","/etc/kamailio/ipsec_P_Inc_Req.sh")
modparam("pcscf","ipsec_P_Out_Rpl","/etc/kamailio/ipsec_P_Out_Rpl.sh")
modparam("pcscf","ipsec_P_Out_Req","/etc/kamailio/ipsec_P_Out_Req.sh")
modparam("pcscf","ipsec_P_Inc_Rpl","/etc/kamailio/ipsec_P_Inc_Rpl.sh")
modparam("pcscf","ipsec_P_Drop","/etc/kamailio/ipsec_P_Drop.sh")

#!ifndef WITH_NAT
modparam("pcscf","NAT_enable", 0)
modparam("pcscf","ping", 0)
modparam("pcscf","ping_all", 0)
#!else
modparam("pcscf","NAT_enable", 1)
modparam("pcscf","ping", 1)
modparam("pcscf","ping_all", 0)
modparam("pcscf","nat_detection_type", 0x17)
modparam("pcscf","rtpproxy_socket", RTPPROXY)
modparam("pcscf","rtpproxy_enable", 1)
modparam("pcscf","rtpproxy_disable_tout", 60)
modparam("pcscf","rtpproxy_retr", 5)
modparam("pcscf","rtpproxy_tout", 1)
#!endif

modparam("pcscf","subscribe_retries", 1)

modparam("pcscf","assert_fallback", 0)

modparam("pcscf","icid_value_prefix","P-CSCFabcd")
modparam("pcscf","icid_gen_addr","109.239.50.67")
modparam("pcscf","orig_ioi","ng-voice.com")
modparam("pcscf","term_ioi","ng-voice.com")

# e2 Interface configuration (NASS-Bundled Authentication)
#modparam("pcscf","forced_clf_peer","clf.ng-voice.com")
modparam("pcscf","use_e2",0)
#modparam("pcscf","use_e2",1)

# PCC interface configuration
#
#!ifndef WITH_RX
modparam("pcscf","use_pcc",0)
#!else
modparam("pcscf","use_pcc",1)
modparam("pcscf","forced_qos_peer","pcrf.ng-voice.com")
# Should it use Gq' (Rel.6) Or Rx (Rel.7)?
modparam("pcscf","qos_release7",1)
# The IP address of the P-CSCF, to build the default signaling bearer with, on registration 
modparam("pcscf","ipv4_for_signaling","109.239.50.67")
modparam("pcscf","ipv6_for_signaling","::1")
modparam("pcscf","port_for_signaling",5060)
#enable or disable using the ports in the IPFilterRule
modparam("pcscf","pcc_use_ports",1)
#Generic gateway configuration
modparam("pcscf","gg_ip","109.239.50.67")
modparam("pcscf","gg_port",10001)
#!endif


#!ifndef WITH_EMERGENCY
#set the emergency support: 0 for disable and 1 for enable
modparam("pcscf","emerg_support",0)
#!else
modparam("pcscf","emerg_support",1)
modparam("pcscf","ecscf_uri", "sip:ecscf.ng-voice.com:7060")
modparam("pcscf","emerg_numbers_file", "/etc/kamailio/emerg_info.xml")
#!endif

# ----- cdp params -----
#!ifdef WITH_RX
# Uncomment here to load C Diameter Peer - requires to enable the e2 or/and PCC interface 
# (NASS-Bundled Authentication / PoCCA - EPC) or the PCRF ones
modparam("cdp", "config_file", "/etc/kamailio/pcscf.xml")
#!endif

# ----- rr params -----
# add value to ;lr param to make some broken UAs happy
modparam("rr", "enable_full_lr", 1)

#!ifdef WITH_TLS
# ----- tls params -----
modparam("tls", "config", "/etc/kamailio/tls.cfg")
#!endif

# -------------------------  request routing logic -------------------

# main routing logic

route {
	# Basic checks for Sanity of the request and Request flooding.	
	route(Sanity_Checks);

	# Add "rport" and validate/add received of first via.
	# Thus P_check_via_sent_by/P_add_via_received is no longer required.
	force_rport();

	if (is_method("REGISTER")) {
		route(REGISTER);
		break;
	}
# Only allow REGISTER as unprotected message 	
#	else {
#		if (!P_is_integrity_protected()){
#			append_to_reply("Proxy-Require: sec-agree\r\n");
#			sl_send_reply("494","Security Agreement Required");
#			exit;
#		}
#	}

	if (is_method("NOTIFY") && uri==myself){
		route(NOTIFY);
		break;
	}

	xlog("L_ERR", "Record-Route-URI: $route_uri\n");
		
	if (!P_mobile_terminating()){
		
		# Request Initiated by the UE
		
		
		if (P_is_in_dialog("orig")){
			if (!is_method("CANCEL")) route(Orig_Subsequent);
			else route(Orig_Standalone);
			break;
		}
		
		if (P_is_in_dialog("term")){
			if (!is_method("CANCEL")) route(Term_Subsequent);
			else route(Orig_Standalone);
			break;
		}
				
		# No dialog yet - ACK not relayed as hop-to-hop
		if (is_method("ACK")){
			t_release();
			break;
		}else						
		if (method=="INVITE" || method=="SUBSCRIBE"){
			route(Orig_Initial);
			break;
		}else{
			if (method=="UPDATE"){
				sl_send_reply("403","Forbidden - Target refresh outside dialog not allowed");
				break;
			}
			if (method=="BYE" || method=="PRACK"){
				sl_send_reply("403","Forbidden - Originating subsequent requests outside dialog not allowed");
				break;
			}
			route(Orig_Standalone);
			break;
		}
		
	}else{

		# TODO - check if this does come from an UE and that UE is unregistered
		
		# Request Terminated by the UE
		
		if (!P_is_in_dialog("term") && 
			(method=="INVITE" || method=="SUBSCRIBE")){
			route(Term_Initial);
			break;
		} else {
			if (P_is_in_dialog("term")){
				if (method!="CANCEL") route(Term_Subsequent);
				else route(Term_Standalone);
				break;
			}else{
				if (method==UPDATE){
					sl_send_reply("403","Forbidden - Target refresh outside dialog not allowed");
					break;
				}
				if (method=="BYE" || method=="ACK" || method=="PRACK"){
					sl_send_reply("403","Forbidden - Terminating subsequent requests outside dialog not allowed");
					break;
				}				
				route(Term_Standalone);
				break;
			}
		}		
		break;
	}

}

route[Sanity_Checks]
{
#!ifdef WITH_ANTIFLOOD
	# flood dection from same IP and traffic ban for a while
	# be sure you exclude checking trusted peers, such as pstn gateways
	# - local host excluded (e.g., loop to self)
	if(src_ip!=myself)
	{
		if($sht(ipban=>$si)!=$null)
		{
			# ip is already blocked
			xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
			exit;
		}
		if (!pike_check_req())
		{
			xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
			$sht(ipban=>$si) = 1;
			exit;
		}
	}
#!endif

	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483","Too Many Hops");
		exit;
	}

	if(!sanity_check("1511", "7"))
	{
		xlog("L_INFO","Malformed SIP message from $si:$sp\n");
		exit;
	}
}

route[Check_Session_Expires]
{
	if (!P_check_session_expires())	{
		P_422_session_expires();
		exit;
	};		
}	


route[REGISTER_494]
{
	append_to_reply("Proxy-Require: sec-agree\r\n");
	t_reply("494","Security Agreement Required");
}

route[REGISTER]
{
    t_newtran();

	if(P_emergency_flag()){
		log(1, ">> emergency flag in REGISTER\n");
		if(!P_emergency_serv_enabled()){	
			P_380_em_alternative_serv("no Emergency Services support at this PCSCF");
			t_reply("503", "Service Unavailable");
			exit;	
		}
    }

	if (!P_verify_security()) {
		route(REGISTER_494);
		break;
	};
	if (!P_is_integrity_protected()){
		#Variant 1 - accept also non IPSec clients
		P_remove_security_client();
		
		#Variant 2 - accept only IPSec clients
		#if (!P_remove_security_client()){
		#	route(REGISTER_494);
		#	break;
		#}
		P_add_integrity_protected("no");
	}else{
		if (!P_remove_security_verify()||!P_remove_security_client()){
			route(REGISTER_494);		
			break;
		}
		P_add_integrity_protected("yes");
	};

	P_remove_header_tag("Require","sec-agree");
	P_remove_header_tag("Proxy-Require","sec-agree");
	P_remove_security_verify();
	P_add_path();
	P_add_require();
	P_add_p_charging_vector();
	P_add_p_visited_network_id("ng-voice.com");
	
	# trigger the UDR on the e2 interface (NASS-Bundled Authentication)
	P_access_network_info("ng-voice.com");

	t_on_reply("REGISTER_reply");
	t_on_failure("REGISTER_failure");
		
	if (!t_relay()) {
		sl_send_reply("500","Error forwarding to Home Domain");
		break;
	};
}

onreply_route[REGISTER_reply]
{
	#log(-1,"Got a response for REGISTER!!!\n");
	if (t_check_status("401")){
		if (!P_remove_ck_ik()){
#			t_reply("500","P-CSCF Error on hiding CK, IK");
			break;
		}
		P_security_401();
	}
	if (t_check_status("200")){
		if (!P_save_location()){
#			t_reply("500","P-CSCF Error on saving location");
			break;
		}		
		P_security_200();
		P_subscribe();
		if(P_is_deregistration()) P_STR("reg");
		else P_AAR("register");		
	}
	if (!P_security_relay()) 	
		P_NAT_relay();
	exit;	
}

failure_route[REGISTER_failure]
{
	#log(-1,"Got a failure for REGISTER!!!\n");
	if (t_check_status("408"))
		t_reply("504","Server Time-Out");
}




route[NOTIFY]
{
	if ( !t_newtran()) {
		sl_reply_error();
		break;
	}		
	if (P_process_notification()) {
		t_reply("200","OK - P-CSCF processed notification");
		break;
	}else{
		t_reply("500","Error encountered while processing notification");
		break;
	}   
}

#######                   ORIGINATING


route[Orig_Initial]
{
	t_newtran();

	log(1,">>       Orig_Initial\n");
	if (P_emergency_ruri()){
		route(Orig_Initial_Emergency);
		break;
	}

	if (!P_is_registered()){
	        sl_send_reply("403","Forbidden - Not Registered! You must register first with a S-CSCF");
	        break;
	};
	if (!P_assert_identity("non-emerg")){
	        sl_send_reply("403","Forbidden - You must register first with a S-CSCF");
	        break;
	};
	# add IBCF/THIG route here if required
	loose_route();
	if (!P_follows_service_routes()){		
		#Variant 1 - deny access to the network
		#sl_send_reply("400","Bad Request - Not following indicated Service-Routes");		    
		#break;
		#Variant 2 - enforce routes and let the dialog continue
   		P_enforce_service_routes();
	}			
	
	P_record_route("orig");

	P_remove_header_tag("Require","sec-agree");
    P_remove_header_tag("Proxy-Require","sec-agree");
    P_remove_security_verify();
	
	P_add_p_charging_vector();	
	
	route(Check_Session_Expires);	
			
	if (!P_save_dialog("orig","non-emerg")){
		sl_send_reply("514","Originating dialog save failure - P-CSCF maximum dialog count reached!");
		exit;
	}
	
	if (method=="INVITE"){
		#P_local_policy(); #check, if sdp is allowed, if not return with allowed sdp
		P_SDP_manipulate("orig");
		#use_media_proxy();
	}
		
	t_on_reply("Orig_Initial_reply");
	t_on_failure("Orig_Initial_failure");
	if (!t_relay()) {
		sl_send_reply("500","Error forwarding originating initial request");
		P_drop_dialog("orig");
		break;
	};
}

route[Orig_Initial_Emergency]
{
	log(1,">>       Emergency Call\n");
	route(Verify_Emergency);

	P_record_route("orig");

	P_remove_header_tag("Require","sec-agree");
    P_remove_header_tag("Proxy-Require","sec-agree");
    P_remove_security_verify();
	
	P_add_p_charging_vector();	
	
	route(Check_Session_Expires);	

	if (!P_save_dialog("orig", "emerg")){
		sl_send_reply("514","Originating dialog save failure - P-CSCF maximum dialog count reached!");
		exit;
	}
	#select and enforce a route to an ECSCF
	if(!P_select_ecscf()){
	        sl_send_reply("503","Internal Error, could not select an E-CSCF");
		exit;
	}
	if(!P_enforce_sos_routes()){
	        sl_send_reply("503","Internal Error, could not select an ECSCF");
	        exit;
	}
	
	if(!P_add_em_path()){
		sl_send_reply("503","Internal Error, could not send the INVITE");
		exit;
	}
		
	if (method=="INVITE"){
		P_SDP_manipulate("orig");
		#use_media_proxy();
	}
		
	t_on_reply("Orig_Initial_reply");
	t_on_failure("Orig_Initial_failure");
	
	if (!t_relay()) {
		sl_send_reply("500","Error forwarding originating initial request");
		P_drop_dialog("orig");
		break;
	};

}

route[Verify_Emergency]
{
	if(!P_emergency_serv_enabled()){
		log(1, ">>  this P-CSCF has no Emergency Services enabled");
		P_380_em_alternative_serv("no Emergency Services support at this PCSCF");
		t_reply("380", "Alternative Services");
		exit;
	}
	
	if (P_is_anonymous_user()){
		if(P_accept_anonym_em_call()){
			log(1,">> Anonymous caller! sending it to E-CSCF\n");
		}else{
			t_reply("503", "Service Unavailable");
			exit;
		}
	}else{
		#non-roaming user
		if(from_uri=~".*@ng-voice\.com.*"){
			if(!P_is_registered()){

				if (!P_is_em_registered()){#TODO: Alternative Service
					P_380_em_alternative_serv("You must first do an Emergency Registration");    
					t_reply("380", "Alternative Services");
		        		exit;
				};
				if (!P_assert_identity("emerg")){
		        		t_reply("403","Forbidden - You must register first with a S-CSCF or use an Anonymous Identity for Emergency");
				        exit;
				};

			}else {
				if (!P_assert_identity("non-emerg")){
		        		t_reply("403","Forbidden - You must register first with a S-CSCF or use an Anonymous Identity for Emergency");
				        exit;
				};
			}
		}else{
			if (!P_is_em_registered()){#TODO: Alternative Service
					P_380_em_alternative_serv("roaming users must first do an Emergency Registration");    
					t_reply("380", "Alternative Services");
		        		exit;
			};
			if (!P_assert_identity("emerg")){
	        		t_reply("403","Forbidden - You must register first with a S-CSCF or use an Anonymous Identity for Emergency");
			        exit;
			};

		}
	
		log(1,">> Registered caller! sending it to E-CSCF\n");
	}

}


onreply_route[Orig_Initial_reply]
{
	log(1,">>       Orig_Initial_reply\n");
	
	if (!t_check_status("(408)|(480)|(487)|(488)|(503)|(603)")){
		P_update_dialog("orig");
	}else{
		P_STR("orig");
		P_drop_dialog("orig");
		break;
	}	
	
	if (t_check_status("(180)|(183)|([2-9]..)")){
		P_SDP_manipulate("orig");
	
		if (P_generates_aar("orig")) {	
			if (!P_AAR("orig")) {
				P_release_call_onreply("orig");
			} else {
				if (!P_security_relay()) P_NAT_relay();		
			}		
		} else {
			if (!P_security_relay()) P_NAT_relay();		
		}
	}

	break;
}

failure_route[Orig_Initial_failure]
{
	log(1,">>       Orig_Initial_failure\n");
	if (t_check_status("(408)|(480)")){
		P_drop_dialog("orig");
		break;
	}
	break;
}


route[Orig_Subsequent]
{
	log(1,">>       Orig_Subsequent\n");
	if (P_is_registered()){
		if (!P_assert_identity("non-emerg")){
		        sl_send_reply("403","Forbidden - You must register first with a S-CSCF");
	    	    break;
		};
	}else if (P_is_em_registered()){
		if (!P_assert_identity("emerg")){
		        sl_send_reply("403","Forbidden - You must register first with a S-CSCF");
	    	    break;
		};
	}

#	else{
		# let it continue as this probably does not come from an UE
        #sl_send_reply("403","Forbidden - Not Registered! You must register first with a S-CSCF");	        
        #break;
        
#	}

	loose_route();

	if (method!="CANCEL" && !P_follows_dialog_routes("orig")){		
		log(1,">>       Orig_Subsequent: Request not following indicated dialog routes\n");
		#Variant 1 - deny access to the network
		#if (method!=ACK){
		#    sl_send_reply("400","Bad Request - Not following indicated dialog routes");
		#} else{
		#	log(1,">>	Orig_Subsequent: ACK not following dialog routes discarded silently!!!\n");
		#}
		#break;
		#Variant 2 - enforce routes and let the dialog continue
		P_enforce_dialog_routes("term");
		#break;
	}	
		
	#P_record_route("orig");

	route(Check_Session_Expires);	

	P_update_dialog("orig");	

	if (method=="INVITE" || method=="ACK" || method=="BYE"){
		P_SDP_manipulate("orig");
	}
	
	if (method=="BYE" || method=="CANCEL"){
		#end_media_session();
		P_STR("orig");		
	}	

	P_remove_header_tag("Require","sec-agree");
        P_remove_header_tag("Proxy-Require","sec-agree");
        P_remove_security_verify();

	# reply routes unused as empty at the moment
	t_on_reply("Orig_Subsequent_reply");
	#t_on_failure("Orig_Subsequent_failure");
	
	if (!t_relay()) {
		sl_send_reply("500","Error forwarding originating subsequent request");
		break;
	};
}

onreply_route[Orig_Subsequent_reply]
{
	log(1,">>       Orig_Subsequent_reply\n");
	
	if (t_check_status("[1-2]..")){
		P_update_dialog("orig");		
		#	P_replace_contact();???
	}
	
	if (t_check_status("2..") && P_generates_aar("orig")){
		if (!P_AAR("orig")) {
			P_release_call_onreply("orig");
			#end_media_session();
			
		} 
	}	
	
	if (!P_security_relay()) 
			P_NAT_relay();
	break;
}

failure_route[Orig_Subsequent_failure]
{
	log(1,">>       Orig_Subsequent_failure\n");
	break;
}


route[Orig_Standalone]
{
	log(1,">>       Orig_Standalone\n");
	
	loose_route();
	t_newtran();
	if (P_emergency_ruri()){
		route(Verify_Emergency);
		if(!P_enforce_sos_routes()){
		        sl_send_reply("503","Internal Error, could not fwd to an E-CSCF");
		        exit;
		}
	}else{	
		if (!P_is_registered()){
		        t_reply("403","Forbidden - You must register first with a S-CSCF");
			break;
		}
		if (!P_assert_identity("non-emerg")){
			t_reply("403","Forbidden - You must register first with a S-CSCF");
	    	    	break;
		};
	
		if (!P_follows_service_routes()){		
			#Variant 1 - deny access to the network
			#sl_send_reply("400","Bad Request - Not following indicated service routes");
			#break;
			#Variant 2 - enforce routes and let the dialog continue
   			P_enforce_service_routes();
		}	
	}

	# add IBCF/THIG route here if required
	
	P_remove_header_tag("Require","sec-agree");
	P_remove_header_tag("Proxy-Require","sec-agree");
	P_remove_security_verify();
	P_add_p_charging_vector();			

	# reply routes unused as empty at the moment
	t_on_reply("Orig_Standalone_reply");
	#t_on_failure("Orig_Standalone_failure");
	
	if (!t_relay()) {
		sl_send_reply("500","Error forwarding originating standalone request");
		break;
	};

}

onreply_route[Orig_Standalone_reply]
{
	log(1,">>       Orig_Standalone_reply\n");
	#P_store_charging();
	if (!P_security_relay()) 
			P_NAT_relay();
	break;
}

failure_route[Orig_Standalone_failure]
{
	log(1,">>       Orig_Standalone_failure\n");
	break;
}


#######                   TERMINATING

route[Term_Initial]
{
	log(1,">>       Term_Initial\n");

	P_record_route("term");

	route(Check_Session_Expires);	

	if (!P_save_dialog("term","non-emerg")){
		sl_send_reply("514","Terminating dialog save failure - P-CSCF maximum dialog count reached!");
		exit;
	}
	
	loose_route();
		
	t_on_reply("Term_Initial_reply");
	#t_on_failure("Term_Initial_failure");
	if (method=="INVITE") {
		P_SDP_manipulate("term");
		#use_media_proxy();
	}	
	if (!P_security_relay()) 
			P_NAT_relay();
	t_on_reply("Term_Initial_reply");
	t_on_failure("Term_Initial_failure");
	if (!t_relay()) {
		sl_send_reply("500","Error forwarding terminating initial request");
		P_drop_dialog("term");
		break;
	};

}


onreply_route[Term_Initial_reply]
{
	log(1,">>       Term_Initial_reply\n");
	if (t_check_status("(180)|(183)|([2-9]..)")){
		P_SDP_manipulate("term");
		if(P_generates_aar("term")){
			# check if QoS is ok, orig - originating, term - terminating 
			if (!P_AAR("term")) {
				P_release_call_onreply("term");
			#   end_media_session();
			#} else {
			#	use_media_proxy(); 
			}			
		}
	}
	
	if (!P_follows_via_list()) {
		log(1,">>      P_follows_via_list - failed");
		P_enforce_via_list();
	};
	
	if (t_check_status("(1[1-9].)|(1.[1-9])|(2..)")){
		if (!P_follows_record_routes()){
			log(1,">>      P_follows_record_routes - failed\n");
			P_enforce_record_routes();
		}	    
	}
	
	if (!t_check_status("(408)|(480)")){
		P_assert_called_identity();
		P_update_dialog("term");		
	}else{
		P_drop_dialog("term");
		P_STR("term");
		break;
	}
	
			
}

failure_route[Term_Initial_failure]
{
	log(1,">>       Term_Initial_failure\n");

	if (t_check_status("(408)|(480)")){
		P_drop_dialog("term");
		break;
	}

	if (!P_follows_via_list()) {
		log(1,">>      P_follows_via_list - failed - this is a bug in P_follows_via_list()!\n");
	#	P_enforce_via_list();
	};

	break;
}



route[Term_Subsequent]
{
	log(1,">>       Term_Subsequent\n");

	route(Check_Session_Expires);	

	P_update_dialog("term");
	
	loose_route();
	
	#P_record_route("term");

	if (method=="INVITE"||method=="ACK" || method=="BYE") {
		P_SDP_manipulate("term");
	}
	
	if (method=="BYE") {
		P_STR("term"); # terminate authorization session
		#end_media_session();
	}	

	P_remove_header_tag("Require","sec-agree");
        P_remove_header_tag("Proxy-Require","sec-agree");
        P_remove_security_verify();

	t_on_reply("Term_Subsequent_reply");
	#t_on_failure("Term_Subsequent_failure");
	if (!P_security_relay()) 
			P_NAT_relay();
	if (!t_relay()) {
		sl_send_reply("500","Error forwarding terminating subsequent request");
		break;
	};

}

onreply_route[Term_Subsequent_reply]
{
	log(1,">>       Term_Subsequent_reply\n");	
	if (!P_follows_via_list()) {
		log(1,">>      P_follows_via_list - failed\n");
		P_enforce_via_list();
	};	
	if (t_check_status("[1-2]..")){
		P_update_dialog("term");		
	}	

	if (t_check_status("(180)|(183)|([2-9]..)")){
		if(P_generates_aar("term")){
			# check if QoS is ok, orig - originating, term - terminating 
			if (!P_AAR("term")) {
				P_release_call_onreply("term");
			#   end_media_session();
			#} else {
			#	use_media_proxy(); 
			}			
		}
	}

	break;
}

failure_route[Term_Subsequent_failure]
{
	log(1,">>       Term_Subsequent_failure\n");	
	if (!P_follows_via_list()) {
		log(1,">>      P_follows_via_list - failed\n");
		P_enforce_via_list();
	};
	break;
}


route[Term_Standalone]
{
	log(1,">>       Term_Standalone\n");

	loose_route();		

	t_on_reply("Term_Standalone_reply");
	#t_on_failure("Term_Standalone_failure");
	if (!P_security_relay()) 
			P_NAT_relay();
	if (!t_relay()) {
		sl_send_reply("500","Error forwarding terminating standalone request");
		break;
	};
	
}

onreply_route[Term_Standalone_reply]
{
	log(1,">>       Term_Standalone_reply\n");
	P_assert_called_identity();
	if (!P_follows_via_list()) {
		log(1,">>      P_follows_via_list - failed\n");
		P_enforce_via_list();
	};
	break;
}

failure_route[Term_Standalone_failure]
{
	log(1,">>       Term_Standalone_failure\n");
	if (!P_follows_via_list()) {
		log(1,">>      P_follows_via_list - failed\n");
		P_enforce_via_list();
	};
	break;
}

